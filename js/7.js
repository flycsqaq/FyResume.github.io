(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{639:function(e,n){e.exports="<pre><code>import { MyPromise } from &quot;./Promise&quot;;\n\nexport const PENDING = &#39;pending&#39;\nexport type PENDING = typeof PENDING\n\nexport const FULFILLED = &#39;fuldilled&#39;\nexport type FULFILLED = typeof FULFILLED\n\nexport const REJECTED = &#39;rejected&#39;\nexport type REJECTED = typeof REJECTED\n\nexport type PromiseStatus = PENDING | FULFILLED | REJECTED\n\nexport interface OnceStatus {\n  isExecute: boolean\n}\n\nexport interface ExecuteOnceStatus {\n  onResolve: (...P: any[]) =&gt; OnResolve | void\n  onReject: (...p: any[]) =&gt; OnReject | void\n  status: OnceStatus\n}\n\nexport interface ExecuteOnce {\n  (promise: MyPromise): ExecuteOnceStatus\n}\n\nexport interface Callback {\n  (value?: any): void\n}\n\nexport interface OnResolve {\n  (input: MyPromise, value?: any): void\n}\n\n\nexport interface OnReject {\n  (input: MyPromise, err?: any): void\n}\n\nexport interface ResolutionProcedure {\n  (input: MyPromise, value?: any): any\n}\n\nexport interface ExecuteCallbacks {\n  (promise: MyPromise): void\n}\n\nexport interface DelayToNextTick {\n  (promise: MyPromise): void\n}\n\nexport interface Defer {\n  promise: MyPromise\n  resolve: Callback\n  reject: Callback\n}\n\nexport interface Test {\n  (): Defer\n}\n\nexport interface TestPromise {\n  deferred: Test\n}</code></pre>"},640:function(e,n){e.exports="<pre><code>import { PENDING, FULFILLED, REJECTED, PromiseStatus, OnceStatus, ExecuteOnceStatus, OnResolve, OnReject, Callback, ExecuteOnce, ExecuteCallbacks, DelayToNextTick, ResolutionProcedure } from &#39;./model&#39;\nconst PromiseState = Symbol(&#39;PromiseState&#39;)\nconst PromiseValue = Symbol(&#39;PromiseValue&#39;)\n\n// 注册回调，避免前后Promise传值而创建的全局状态管理\nconst onFilFulledMap: Map&lt;MyPromise, Callback[]&gt; = new Map()\nconst onRejectedMap: Map&lt;MyPromise, Callback[]&gt; = new Map()\n\nconst nextPromisesMap: Map&lt;MyPromise, MyPromise[]&gt; = new Map()\n\n/**\n * 高阶函数,使得传入的Promise的resolve,reject同时只能被执行一次\n * @param {MyPromise} promise -需要只能执行一次resolve/reject的Promise对象\n * @returns {Object} -返回对象，onResolve与onReject为封装后的函数,status为状态对象，获取Promise的resolve/reject能否执行的信息\n */\nconst executeOnce: ExecuteOnce = (promise: MyPromise): ExecuteOnceStatus =&gt; {\n  let status: OnceStatus = {isExecute: false}\n  return {\n    onResolve: (...p: any[]) =&gt; {\n      if (!status.isExecute) {\n        status.isExecute = true\n        return resolve(promise, ...p)\n      }\n    },\n    onReject: (...p: any[]) =&gt; {\n      if (!status.isExecute) {\n        status.isExecute = true\n        return reject(promise, ...p)\n      }\n    },\n    status\n  }\n}\n\n/**\n * 执行promise的callback\n * @param {MyPromise} promise -需要执行回调的Promise对象\n * @returns\n */\nconst executeCallbacks: ExecuteCallbacks = (promise: MyPromise): void =&gt; {\n  const state: boolean = promise[PromiseState] === FULFILLED\n  const value: any = promise[PromiseValue]\n  const callbackMap: Map&lt;MyPromise, Callback[]&gt; = state ? onFilFulledMap: onRejectedMap\n\n  const callbacks = callbackMap.get(promise) as Callback[]\n  const nextPromises = nextPromisesMap.get(promise) as MyPromise[]\n\n  //重置promise的回调，避免重复执行\n  callbackMap.set(promise, [])\n  nextPromisesMap.set(promise, [])\n\n  callbacks.forEach((callback: Callback, index: number) =&gt; {\n    let result: any = value\n    let status: boolean = state\n    if (typeof callback === &#39;function&#39;) {\n      try {\n        result = callback(value)\n        status = true\n      } catch(e) {\n        result = e\n        status = false\n      }\n    }\n    const nextPromise: MyPromise = nextPromises[index]\n    if (nextPromise instanceof MyPromise) {\n      (status? resolve: reject)(nextPromise, result)\n    }\n  })\n}\n\n/**\n * 获取一个可以延时执行函数的函数\n * @param {Function} fn -需延时执行的函数\n * @param {...any} [args] -传入延时函数的参数\n */\nconst delayFn: Function = (() =&gt; {\n  return (fn: Function, ...p: any[]) =&gt; setTimeout(fn, 0, ...p)\n})()\n\nconst delayToNextTick: DelayToNextTick = (promise: MyPromise): void =&gt; {\n  // 修复无回调函数，也会注册微任务的bug\n  const callbackMap: Map&lt;MyPromise, Callback[]&gt; = promise[PromiseState] === FULFILLED? onFilFulledMap: onRejectedMap\n  const callbacks = callbackMap.get(promise) as Callback[]\n  if (callbacks &amp;&amp; callbacks.length !== 0) {\n    delayFn(\n      executeCallbacks,\n      promise\n    )\n  }\n}\n\n\n/**\n *Promise解析流程\n * @param {MyPromise} promise -需要解析Promise对象\n * @param {any} x -传入的值\n * [https://promisesaplus.com/] The Promise Resolution Procedure 官方提供的解析流程\n */\nconst resolutionProcedure: ResolutionProcedure = (promise: MyPromise, x?: any): any =&gt; {\n  if (promise instanceof MyPromise &amp;&amp; promise === x) {\n    return reject(promise, new TypeError())\n  }\n  const { onReject, onResolve, status } = executeOnce(promise)\n  if (x instanceof MyPromise) {\n    if (x[PromiseState] === PENDING) {\n      x.then(onResolve, onReject)\n    } else {\n      promise[PromiseState] = x[PromiseState]\n      promise[PromiseValue] = x[PromiseValue]\n      delayToNextTick(promise)\n    }\n    return\n  }\n  if (x &amp;&amp; (typeof x === &#39;function&#39; || typeof x === &#39;object&#39;)) {\n    let then\n    try {\n      then = x.then\n    } catch(e) {\n      return reject(promise, e)\n    }\n    if (typeof then === &#39;function&#39;) {\n      try {\n        then.call(x, onResolve, onReject) // 不需要闭包控制只执行一次，因为x不是Promise对象\n      } catch(e) {\n        // 保证抛出异常之前执行了resolve/reject，异常会无效\n        if (!status.isExecute) {\n          onReject(e)\n        }\n      }\n      return\n    }\n  }\n  // 若x是简单类型的值，则改变promise的状态与值\n  promise[PromiseState] = FULFILLED\n  promise[PromiseValue] = x\n\n  delayToNextTick(promise)\n}\n\n\n/**\n * 将状态转移至fulfilled\n * @param {MyPromise} input -传入的Promise\n * @param {any} value -传入的promise结果值\n * @returns\n */\nconst resolve: OnResolve = (input, value) =&gt; {\n  if (input[PromiseState] !== PENDING) return\n  resolutionProcedure(input, value)\n}\n\n\n/**\n * 将状态转移至rejected\n * @param {MyPromise} input -传入的Promise\n * @param {any} err -错误原因\n * @returns\n */\nconst reject: OnReject = (input, err) =&gt; {\n  if (input[PromiseState] !== PENDING) return\n  input[PromiseState] = REJECTED\n  input[PromiseValue] = err\n  const callbacks = onRejectedMap.get(input) as Callback[]\n  delayToNextTick(input)\n}\n\n\n/**\n * 按照PromiseA+规范实现的Promise\n *@class MyPromise\n */\nexport class MyPromise {\n  public [PromiseState]: PromiseStatus\n  public [PromiseValue]: any\n  constructor(execute?: Function) {\n    this[PromiseState] = PENDING\n    this[PromiseValue] = undefined\n\n    nextPromisesMap.set(this, [])\n    onFilFulledMap.set(this, [])\n    onRejectedMap.set(this, [])\n\n    if (typeof execute === &#39;function&#39;) {\n      const { onResolve, onReject, status } = executeOnce(this)\n      try {\n        execute(onResolve, onReject)\n      } catch(e) {\n        //保证抛出异常前执行了resolve/reject\n        if (!status.isExecute) {\n          onReject(e)\n        }\n      }\n    }\n  }\n\n  /**\n   * 注册回调方法\n   * @param {Function} onFilfulled\n   * @param {Function} onReject\n   * @returns {MyPromise} newPromise\n   */\n  then(onFilfulled: Callback, onReject: Callback): MyPromise {\n    (onFilFulledMap.get(this) as Callback[]).push(onFilfulled) as number\n    (onRejectedMap.get(this) as Callback[]).push(onReject) as number\n\n    if (this[PromiseState] !== PENDING) delayToNextTick(this)\n\n    const newPromise: MyPromise = new MyPromise();\n    (nextPromisesMap.get(this) as MyPromise[]).push(newPromise)\n\n    return newPromise\n  }\n}\n</code></pre>"},641:function(e,n){e.exports='<h1 id="promise-解析">Promise 解析</h1>\n<h2 id="前言">前言</h2>\n<p>本文从 PromiseA+规范出发,逐步构造一个符合规范的 Promise.</p>\n<h2 id="1-同步与异步">1. 同步与异步</h2>\n<p>同步与异步是相对于 js 代码的运行而言，单线程的渲染引擎本身并没有异步。异步编程在 js 中只不过是对渲染引擎执行 js 代码的一种控制罢了。例如:</p>\n<pre><code>while(queue.waitForMessage()) {\n    queue.processNextMessage()\n}</code></pre><p>如果当前没有任何消息，<code>queue.waitForMessage()</code> 会同步地等待消息到达。有消息到达后，执行<code>queue.processNextMessage()</code>,因此，单线程异步编程做的只不过是何时将消息推入消息队列中。</p>\n<h2 id="2-processnextmessage">2. processNextMessage()</h2>\n<p>那么，<code>processNextMessage</code>的执行是怎样的呢?在这里，我们主要关注的是 js 消息。如果说 js 消息不分种类，那么，对其来说<code>processNextMessage</code>就只不过是对时间流的控制，即先进消息队列的必定先触发。但有时候我们想要进行插队，如果这个插队接口直接暴露给程序员，例如<code>queue.jump(...args)</code>，那么对于我们而言就必然需要一个接口来获取消息队列中的所有消息的信息。这样实现异步，光是想想就觉得困难。因为正在执行的函数获取队列的信息，然后进行插队，Oh my god!这不是队列。</p>\n<p>例如，我们通过 ajax 请求获取信息，然后对信息进行插队，那么我们要思考如何插队。这也许可以达到精准控制，但实在是没这个必要。而且每一次信息的处理都会触发一次 layout，processNextMessage 除了搞定 js 代码之外还需要进行布局。因此，基于以上考虑，微任务诞生了。</p>\n<h2 id="3-promise">3. Promise</h2>\n<p>Promise.then()是注册微任务的一种方式，但实际上是由 resolve/reject 调用微任务队列暴露出的接口向其推入一个消息，<code>then</code>做的只不过是注册回调罢了。</p>\n<h2 id="4-代码分析">4. 代码分析</h2>\n<pre><code>new Promise((resovle, reject) =&gt; {\n    setTimeout(() =&gt; {\n        resovle(0)\n    }, 0)\n}).then(res =&gt; {\n    console.log(res)\n}).catch(err =&gt; {\n    console.log(err)\n})</code></pre><ol>\n<li><p>创建 Promise 实例，setTimeout 通知注册表，在 0 秒后向宏任务队列中推入一个任务，并通过 then 方法注册成功后的回调，catch 方法用于捕获错误，是对避免错过错误的一种防御性的编程。</p>\n</li>\n<li><p>渲染引擎执行 layout 之后在下一次 processNextMessage 时先执行微任务队列中的消息，但其为空。接着执行 setTimeout 所注册的<code>() =&gt; resolve(0)</code>,它做的只不过是改变了 Promise 的状态与数据，以及向微任务队列中推入一个消息，用于执行注册的回调。也就是<code>res =&gt; console.log(res)</code>。</p>\n</li>\n<li><p>渲染引擎在执行 layout 之后，在下一次 processNextMessage 时先执行微任务队列中的消息，即<code>res =&gt; console.log(res)</code>。</p>\n</li>\n<li><p>catch 所注册的<code>err =&gt; { console.log(err) }</code>,因为没有抛出 error，所以不会被调用。</p>\n</li>\n</ol>\n'},646:function(e,n,t){"use strict";t.r(n);var o=t(1),s=t.n(o),r=t(237),a=t(639),i=t.n(a),c=t(640),l=t.n(c),p=t(641),m=t.n(p),u=t(229),P=t.n(u),x=(t(227),function(){return(x=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var s in n=arguments[t])Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s]);return e}).apply(this,arguments)});n.default=function(){var e=[{name:"promiseArticle",md:m.a},{name:"promiseType",md:i.a},{name:"promiseCode",md:l.a}];return s.a.createElement(P.a,null,e.map(function(e){return s.a.createElement(P.a.TabPane,{key:e.name,tab:e.name},s.a.createElement(r.a,x({},e)))}))}}}]);