(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{619:function(e,n,t){e.exports='<h2 id="事件循环">事件循环</h2>\n<p>eventloop 简化模型.</p>\n<p><img src="'+t(620)+'" alt="流程图"></p>\n<h3 id="1-任务队列">1. 任务队列</h3>\n<p>出列与入列.</p>\n<pre><code>function Queue() {\n    const messages = []\n    const popMessage = () =&gt; {\n        return messages.pop()\n    }\n    const pushMessage = () =&gt; {\n        return messages\n    }\n    return {\n        pop: popMessage,\n        push: pushMessage\n    }\n}\nconst microQueue = new Queue() // 宏任务队列\nconst macroQueue = new Queue() // 微任务队列</code></pre><h3 id="2-注册表">2. 注册表</h3>\n<p>注册表提供了其他模块与 js 引擎进行交互的功能,具体实现方式可能是<code>while(true)</code>,也可能是观察订阅模式.</p>\n<pre><code>function Observable(fn, tag = true) {\n    const notification = () =&gt; {\n        if (tag) {\n            microQueue.add(fn)\n        } else {\n            macroQueue.add(fn)\n        }\n    }\n    return {\n        notification\n    }\n}\n// registry注册了外部与Observable的关系,外部调用Observable.notification,registry为其他模块与js引擎交互的唯一方式,且能够做记录与进行调试.\nconst registry = {}</code></pre><h3 id="3-js-运行">3. js 运行</h3>\n<pre><code>// 执行传入的函数\nconst execute = fn =&gt; {\n    if (typeof fn === &#39;function&#39;) {\n        fn()\n        return true\n    }\n    return false\n}\n\n// 执行微任务队列中的所有任务\nconst executeMicro = () =&gt; {\n    let task = microQueue.pop()\n    let tag = true\n    while (tag) {\n        tag = task()\n        task = microQueue.pop()\n    }\n}\n\nconst processNextTick() {\n    dosomething1()\n\n    executeMicro()\n    execute(macroQueue.pop())\n\n    dosomething2()\n}\n\n// 事件循环\nwhile(true) {\n    processNextTick()\n}</code></pre>'},620:function(e,n,t){e.exports=t.p+"img/eventloop.2bd012.jpg"},621:function(e,n){e.exports='<h1 id="问题">问题</h1>\n<h2 id="1-引用外部-css-样式文件">1. 引用外部 css 样式文件</h2>\n<h3 id="11-问题描述">1.1 问题描述</h3>\n<p>&emsp;&emsp;在引用外部 css 文件(例如 github-markdown.css)时,因为对 sass 文件进行了模块化配置,因此这些 css 样式文件如果在 sass 文件中导入,会生成<code>*.d.ts</code>文件,在打包过程中会给类名添加哈希值,因此在 html 标签上直接添加 class 无法与模块化的样式进行匹配.</p>\n<h3 id="12-解决方法">1.2 解决方法</h3>\n<ol>\n<li>导入模块化样式,设置 class,这样做可能会有未满足某些模块化命名问题.例如<code>markdown-body</code>不满足驼峰命名.</li>\n<li>将<code>css</code>文件与<code>sass</code>文件区分,webpack 中 css 样式不进行模块化配置,在<code>css</code>文件中导入引用的样式表,这样做也可以解决问题.</li>\n</ol>\n<h2 id="2-代码分离">2. 代码分离</h2>\n'},622:function(e,n){e.exports='<h1 id="问题">问题</h1>\n<h2 id="1-如何添加路由动画">1. 如何添加路由动画</h2>\n<ol>\n<li>Switch 组件用于迭代所有 Route 子元素,渲染与当前位置匹配的第一个子元素.</li>\n<li>react-motion 的 Motion 组件可用于制作单组件动画效果.</li>\n</ol>\n<p>&emsp;&emsp;可用 react-motion 制作入场动画.那么如何制作出场动画呢?出场动画必然涉及到 dom 操作,需要显示声明组件的销毁,那么必然涉及到 Switch 组件对 Route 组件的某些操作,如何用 hooks 实现呢?可以用<code>react-transition-group</code>库实现.</p>\n<ol start="3">\n<li>组件切换动画可以使用 TransitionMotion 组件.</li>\n</ol>\n<h2 id="2-markdown-代码高亮，并且记忆当前阅读位置">2. markdown 代码高亮，并且记忆当前阅读位置</h2>\n<h3 id="21-markdown-代码高亮">2.1 markdown 代码高亮</h3>\n<p>&emsp;&emsp;使用 highlight.js 库实现代码高亮，highlightBlock 接口可以使传入的 DOM 节点代码高亮。即在 DOM 渲染后调用 highlightBlock 函数。因此可以在 componentDidMount 钩子中调用。</p>\n<h3 id="22-记忆当前阅读位置">2.2 记忆当前阅读位置</h3>\n<p>&emsp;&emsp; 通过 localStorage 保存阅读文章的<code>window.scrollY</code></p>\n<h3 id="问题描述">问题描述</h3>\n<p>&emsp;&emsp;antd Tabs 组件多个文章组件销毁时触发多次 setState，导致数据被合并的问题。</p>\n<h3 id="解决方法">解决方法</h3>\n<p>&emsp;&emsp;通过 ref 获取文章的 dom 节点，通过 getBoundingClientRect 计算 dom 节点的高度，绑定 scroll 事件，更新数据。</p>\n<h2 id="3-usestate-异步更新问题">3. useState 异步更新问题</h2>\n<p>因此 useState 是基于 setState 实现的，因此也存在异步更新问题。</p>\n<h3 id="31-setstate-是如何解决的">3.1 setState 是如何解决的</h3>\n<blockquote>\n<p>可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数。</p>\n</blockquote>\n<pre><code>this.setState((state, props) =&gt; ({\n  counter: state.counter + props.increment\n}));</code></pre><h3 id="32-usestate-可以怎么做？">3.2 useState 可以怎么做？</h3>\n<p>我们可以通过闭包的方式不直接修改 state，而是修改闭包中的变量。相当于增加一个代理，用于修改 state。例如：</p>\n<pre><code>const [counter, setCounter] = useState(0);\nconst addCounter = (function() {\n    let cacheCounter = counter\n    return () =&gt; {\n        cacheCounter = cacheCounter + 1;\n        setCounter(cacheCounter);\n    }\n}())</code></pre><p>事实上，这种依赖于前一个数据的 state 依靠 useReducer 来实现更为妥当。</p>\n'},640:function(e,n,t){"use strict";t.r(n);var o=t(1),s=t.n(o),c=t(246),r=t(619),i=t.n(r),p=t(621),a=t.n(p),u=t(622),d=t.n(u),h=function(){return(h=Object.assign||function(e){for(var n,t=1,o=arguments.length;t<o;t++)for(var s in n=arguments[t])Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s]);return e}).apply(this,arguments)};n.default=function(e){var n={"/blog/eventloop":{md:i.a,name:"eventloop"},"/question/webpack":{md:a.a,name:"webpack"},"/question/react":{md:d.a,name:"react"}};return s.a.createElement(c.a,h({},n[e.location.pathname]))}}}]);