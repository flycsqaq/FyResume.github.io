(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{623:function(n,e,t){n.exports='<h1 id="图片加载方案代理模式">图片加载方案(代理模式)</h1>\n<h2 id="1-流程图">1. 流程图</h2>\n<p><img src="'+t(624)+'" alt="图片加载方案"></p>\n<h2 id="2-为什么使用代理模式">2. 为什么使用代理模式</h2>\n<p>图片加载无论是监听 scroll 事件还是通过 IntersectionObserver 对象，都是发布订阅模式。但除此之外，我们还需要根据某些条件来判断是否执行订阅者的函数。那么所需要的便是如何执行这个用于判断的函数。即<code>f(x) =&gt; f(g(x))</code>,在这里，<code>g(x)</code>可以被替换。这很适合用代理模式。</p>\n<h2 id="3-总体框架">3. 总体框架</h2>\n<pre><code>// 保存某些必要的数据\nconst container = {\n    attr: &#39;data-img&#39;,\n    intersection: new IntersectionObserver(fn),\n    els: []\n}\nconst client = {\n    observeEls: () =&gt; {},\n    unobserveEls: () =&gt; {}\n}\n\nconst proxy = {\n    receive: () =&gt; {},\n    notice: () =&gt; {\n        loadImages()\n    }\n}\n\nconst loadImages = () =&gt; {}</code></pre><h2 id="3-客户发布者">3. 客户(发布者)</h2>\n<p>IntersectionObserver 对象传入一个函数，当监听的元素出现在可视窗口或从可视窗口移出时，触发的回调函数。<code>isIntersecting</code>属性为布尔值，<code>true</code>表示元素从外部移入可视窗口，<code>false</code>表示从可视窗口移出。</p>\n<pre><code>const intersection = new IntersectionObserver(obs =&gt; {\n    // 可见元素数组\n    const visibleEls = obs.filter(ob =&gt; ob.isIntersecting).map(ob =&gt; obs.target)\n    // 不可见元素数组\n    const invisibleEls = obs.filter(ob =&gt; !(ob.isIntersecting)).map(ob =&gt; obs.target)\n    proxy.receive(visibleEls, invisibleEls)\n})</code></pre><h2 id="4-代理">4. 代理</h2>\n<p>proxy 可以接收客户的信息，并向主体发出加载图片的请求。<br>例如:</p>\n<pre><code>// 如何接收信息\nconst receive = (visibleEls, invisibleEls) =&gt; {\n    // 移除从可视窗口移出的元素\n    invisibleEls.forEach(el =&gt; {\n        const index = container.els.indexOf(el)\n        if (index &gt; -1) {\n            container.els.splice(index, 1)\n        }\n    })\n    // 添加从外部移入可视窗口的元素\n    container.els = Array.from(new Set(container.els.concat(visibleEls)))\n    proxy.notice()\n}\n\n// 如何发送请求,可以通过闭包的方式很轻松地实现节流与防抖\nconst createNotice = () =&gt; {\n    return (els) =&gt; {\n        loadImage(els)\n    }\n}</code></pre><h2 id="5-加载图片">5. 加载图片</h2>\n<pre><code>const loadImages = (els) =&gt; {\n    els.forEach(el =&gt; {\n        const url = el.getAttribute(container.attr);\n        if (url) {\n            el.src = url;\n            el.removeAttribute(at);\n            container.intersection.unobserve(el)\n        }\n    })\n}</code></pre>'},624:function(n,e,t){n.exports=t.p+"img/img_load.17fed3.jpg"},625:function(n,e){n.exports="<pre><code>enum State {\n    NOTLOAD = &#39;notload&#39;,\n    WILLLOAD = &#39;willload&#39;\n}\n\nlet count = 1;\n\nexport const loadImage = () =&gt; {\n    let counter = count++; // 记录\n\n    // 代理抽象类，通过扩展notic函数制造你想要的代理\n    class AbstractImageProxy {\n        public els: Element[];\n        public constructor() {\n            this.els = [];\n        }\n        public addEls(els: Element[]) {\n            this.els = Array.from(new Set(this.els.concat(els)));\n        }\n        public removeEls(els: Element[]) {\n            const iterator = els.values();\n            for (const el of iterator) {\n                const index = this.els.indexOf(el);\n                if (index &gt; -1) {\n                    this.els.splice(index, 1);\n                }\n            }\n        }\n        public clearEls() {\n            this.els = [];\n        }\n        /**\n         * 观察者调用的函数，另类的订阅者\n         * @method\n         */\n        public notice() {\n            throw new Error(&#39;please extends AbstractImageProxy&#39;);\n        }\n        public relay() {\n            loadImages(this.els as HTMLImageElement[]);\n            this.clearEls();\n        }\n    }\n    // 内置的普通懒加载\n    class ImageProxy extends AbstractImageProxy {\n        /**\n         * 只是转发加载图片的请求\n         * @method\n         */\n        public notice() {\n            this.relay();\n        }\n    }\n\n    /**\n     * 内置的节流懒加载\n     * @param {number} interval 加载的间隔时间\n     */\n    class ThrottlingProxy extends AbstractImageProxy {\n        public state: State;\n        public interval: number;\n        public constructor(interval: number = 300) {\n            super();\n            this.state = State.NOTLOAD;\n            this.interval = interval;\n        }\n        /**\n         * 通过状态判断是否转发请求\n         * @method\n         */\n        public notice() {\n            if (this.state === State.WILLLOAD) return;\n            this.state = State.WILLLOAD;\n            const load = () =&gt; {\n                this.relay();\n                this.state = State.NOTLOAD;\n            };\n            // 直接传递this.replay,无法获取上下文\n            setTimeout(load, this.interval);\n        }\n    }\n    // 内置的防抖懒加载\n    class DebounceProxy extends AbstractImageProxy {\n        public timer: number; // 记录上次调用的时间戳\n        public timeId: any; // 记录setTimeout的id\n        public interval: number;\n        public constructor() {\n            super();\n            this.timer = Date.now();\n            this.timeId = -1;\n            this.interval = 1000;\n        }\n        /**\n         * 通过时间间隔判断是否转发请求\n         * @member\n         */\n        public notice() {\n            const now = Date.now();\n            if (now - this.timer &gt; this.interval) {\n                this.relay();\n                if (this.timeId &gt; -1) {\n                    clearTimeout(this.timeId);\n                    this.timeId = -1;\n                }\n            } else {\n                if (this.timeId &gt; -1) {\n                    clearTimeout(this.timeId);\n                }\n                // 直接传递this.replay,无法获取上下文\n                this.timeId = setTimeout(() =&gt; this.relay(), this.interval);\n            }\n            this.timer = now;\n        }\n    }\n    const attr = &#39;data-img&#39;;\n    let els: Element[] = [];\n    let proxy: AbstractImageProxy = new ImageProxy();\n\n    /**\n     * 改变代理者，自定义图片加载的节奏\n     * @param {AbstractImageProxy} inputProxy\n     */\n    const changeProxy = (inputProxy: AbstractImageProxy) =&gt; {\n        if (inputProxy instanceof AbstractImageProxy) {\n            proxy = inputProxy;\n        } else {\n            throw new Error(&#39;please change a proxy extends AbstractImageProxy&#39;);\n        }\n    };\n\n    // 搜集元素\n    const popularEls = () =&gt; {\n        els = Array.from(document.querySelectorAll(`[${attr}]`));\n    };\n\n    // 监听图片是否出现在可视区域\n    const intersection = new IntersectionObserver(obs =&gt; {\n        proxy.addEls(obs.filter(ob =&gt; ob.isIntersecting).map(ob =&gt; ob.target));\n        proxy.removeEls(obs.filter(ob =&gt; !ob.isIntersecting).map(ob =&gt; ob.target));\n        proxy.notice();\n    });\n\n    /**\n     * 加载图片，移除data-img属性\n     * @param {HTMLImageElement[]} els\n     */\n    const loadImages = (els: HTMLImageElement[]) =&gt; {\n        els.forEach(el =&gt; {\n            loadImg(el);\n        });\n    };\n\n    const loadImg = (el: HTMLImageElement) =&gt; {\n        const at = attr;\n        const url = el.getAttribute(at);\n        if (url) {\n            el.src = url;\n            el.removeAttribute(at);\n            unobserve(el);\n        }\n    };\n\n    // 取消监听某个元素\n    const unobserve = (el: HTMLImageElement) =&gt; {\n        intersection.unobserve(el);\n    };\n\n    // 开始监听\n    const observes = () =&gt; {\n        els.forEach(el =&gt; {\n            intersection.observe(el);\n        });\n    };\n    // 取消所有元素的监听\n    const disconnect = () =&gt; {\n        intersection.disconnect();\n    };\n    return {\n        els,\n        observes,\n        unobserve,\n        popularEls,\n        ImageProxy,\n        ThrottlingProxy,\n        DebounceProxy,\n        AbstractImageProxy,\n        changeProxy,\n        disconnect,\n        counter\n    };\n};</code></pre>"},626:function(n,e,t){var r={"./Sylvanas1.jpg":627,"./Sylvanas10.jpg":628,"./Sylvanas2.jpg":629,"./Sylvanas3.jpg":630,"./Sylvanas4.jpg":631,"./Sylvanas5.jpg":632,"./Sylvanas6.jpg":633,"./Sylvanas7.jpg":634,"./Sylvanas8.jpg":635,"./Sylvanas9.jpg":636};function o(n){var e=i(n);return t(e)}function i(n){if(!t.o(r,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return r[n]}o.keys=function(){return Object.keys(r)},o.resolve=i,n.exports=o,o.id=626},627:function(n,e,t){n.exports=t.p+"img/Sylvanas1.5fc82e.jpg"},628:function(n,e,t){n.exports=t.p+"img/Sylvanas10.a3a72f.jpg"},629:function(n,e,t){n.exports=t.p+"img/Sylvanas2.bee4aa.jpg"},630:function(n,e,t){n.exports=t.p+"img/Sylvanas3.7c0f24.jpg"},631:function(n,e,t){n.exports=t.p+"img/Sylvanas4.f0fd83.jpg"},632:function(n,e,t){n.exports=t.p+"img/Sylvanas5.553fc0.jpg"},633:function(n,e,t){n.exports=t.p+"img/Sylvanas6.8fc18e.jpg"},634:function(n,e,t){n.exports=t.p+"img/Sylvanas7.ddfb13.jpg"},635:function(n,e,t){n.exports=t.p+"img/Sylvanas8.476572.jpg"},636:function(n,e,t){n.exports=t.p+"img/Sylvanas9.aaedbc.jpg"},642:function(n,e,t){"use strict";t.r(e);var r,o,i=t(1),a=t.n(i),s=function(n){return a.a.createElement("div",null,n.imgs.map(function(n,e){return a.a.createElement("img",{style:{display:"block"},key:e,"data-img":n,height:300,width:400})}))},c=(r=function(n,e){return(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)e.hasOwnProperty(t)&&(n[t]=e[t])})(n,e)},function(n,e){function t(){this.constructor=n}r(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}),l=function(n){var e="function"==typeof Symbol&&n[Symbol.iterator],t=0;return e?e.call(n):{next:function(){return n&&t>=n.length&&(n=void 0),{value:n&&n[t++],done:!n}}}};!function(n){n.NOTLOAD="notload",n.WILLLOAD="willload"}(o||(o={}));var u=1,p=t(247),m=t.n(p),g=(t(236),t(246)),f=t(623),d=t.n(f),y=t(625),b=t.n(y),h=function(n,e){var t="function"==typeof Symbol&&n[Symbol.iterator];if(!t)return n;var r,o,i=t.call(n),a=[];try{for(;(void 0===e||e-- >0)&&!(r=i.next()).done;)a.push(r.value)}catch(n){o={error:n}}finally{try{r&&!r.done&&(t=i.return)&&t.call(i)}finally{if(o)throw o.error}}return a};e.default=function(){var n=function(){for(var n=[],e=1;e<11;e++)n.push(t(626)("./Sylvanas"+e+".jpg"));return n}(),e=function(n){var e=function(){var n=u++,e=function(){function n(){this.els=[]}return n.prototype.addEls=function(n){this.els=Array.from(new Set(this.els.concat(n)))},n.prototype.removeEls=function(n){var e,t,r=n.values();try{for(var o=l(r),i=o.next();!i.done;i=o.next()){var a=i.value,s=this.els.indexOf(a);s>-1&&this.els.splice(s,1)}}catch(n){e={error:n}}finally{try{i&&!i.done&&(t=o.return)&&t.call(o)}finally{if(e)throw e.error}}},n.prototype.clearEls=function(){this.els=[]},n.prototype.notice=function(){throw new Error("please extends AbstractImageProxy")},n.prototype.relay=function(){m(this.els),this.clearEls()},n}(),t=function(n){function e(){return null!==n&&n.apply(this,arguments)||this}return c(e,n),e.prototype.notice=function(){this.relay()},e}(e),r=function(n){function e(e){void 0===e&&(e=300);var t=n.call(this)||this;return t.state=o.NOTLOAD,t.interval=e,t}return c(e,n),e.prototype.notice=function(){var n=this;this.state!==o.WILLLOAD&&(this.state=o.WILLLOAD,setTimeout(function(){n.relay(),n.state=o.NOTLOAD},this.interval))},e}(e),i=function(n){function e(){var e=n.call(this)||this;return e.timer=Date.now(),e.timeId=-1,e.interval=1e3,e}return c(e,n),e.prototype.notice=function(){var n=this,e=Date.now();e-this.timer>this.interval?(this.relay(),this.timeId>-1&&(clearTimeout(this.timeId),this.timeId=-1)):(this.timeId>-1&&clearTimeout(this.timeId),this.timeId=setTimeout(function(){return n.relay()},this.interval)),this.timer=e},e}(e),a=[],s=new t,p=new IntersectionObserver(function(n){s.addEls(n.filter(function(n){return n.isIntersecting}).map(function(n){return n.target})),s.removeEls(n.filter(function(n){return!n.isIntersecting}).map(function(n){return n.target})),s.notice()}),m=function(n){n.forEach(function(n){g(n)})},g=function(n){var e="data-img",t=n.getAttribute(e);t&&(n.src=t,n.removeAttribute(e),f(n))},f=function(n){p.unobserve(n)};return{els:a,observes:function(){a.forEach(function(n){p.observe(n)})},unobserve:f,popularEls:function(){a=Array.from(document.querySelectorAll("[data-img]"))},ImageProxy:t,ThrottlingProxy:r,DebounceProxy:i,AbstractImageProxy:e,changeProxy:function(n){if(!(n instanceof e))throw new Error("please change a proxy extends AbstractImageProxy");s=n},disconnect:function(){p.disconnect()},counter:n}}();return null!==v&&v.disconnect(),setTimeout(function(){e.popularEls();var t=e[n];e.changeProxy(new t),e.observes(),null!==v&&(v.disconnect(),x(e)),x(v)},0),e},r=h(Object(i.useState)("ImageProxy"),2),p=r[0],f=r[1],y=h(Object(i.useState)(null),2),v=y[0],x=y[1];Object(i.useEffect)(function(){var n=e(p);return function(){n.disconnect()}},[p]);return a.a.createElement(m.a,{defaultActiveKey:"ImageProxy",onChange:function(n){return function(n){"code"!==n&&"codeShow"!==n&&f(n)}(n)}},a.a.createElement(m.a.TabPane,{key:"ImageProxy",tab:"普通懒加载"},a.a.createElement(s,{imgs:n}),";"),a.a.createElement(m.a.TabPane,{key:"ThrottlingProxy",tab:"节流"},a.a.createElement(s,{imgs:n}),";"),a.a.createElement(m.a.TabPane,{key:"DebounceProxy",tab:"防抖"},a.a.createElement(s,{imgs:n}),";"),a.a.createElement(m.a.TabPane,{key:"code",tab:"代码分析"},a.a.createElement(g.a,{name:"lazyLoad",md:d.a})),a.a.createElement(m.a.TabPane,{key:"codeShow",tab:"代码"},a.a.createElement(g.a,{name:"randomCode",md:b.a})))}}}]);